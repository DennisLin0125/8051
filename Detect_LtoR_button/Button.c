/*-----------------------------------------------
  名稱：單個獨立按鍵依次輸入控制
  編寫：Dennis
  日期：2020.9.22
  修改：無
  內容：偵測按鍵,如計算器輸入數據形式相同 從左往右
------------------------------------------------*/
#include<reg52.h> //包含標頭檔案，一般情況不需要改動，標頭檔案包含特殊功能暫存器的定義
/*------------------------------------------------
                    定義按鍵
------------------------------------------------*/
sbit KEY1=P3^0;  //定義按鍵輸入埠
sbit KEY2=P3^1;
sbit KEY3=P3^2;
sbit KEY4=P3^3;
sbit KEY5=P3^4;
sbit KEY6=P3^5;
sbit KEY7=P3^6;
sbit KEY8=P3^7;

/*------------------------------------------------
                   定義數碼管介面
------------------------------------------------*/
#define DataPort P0 //定義數據埠 程式中遇到DataPort 則用P0 替換
sbit LATCH1=P2^2;//定義鎖存使能埠 段鎖存
sbit LATCH2=P2^3;//                 位鎖存

unsigned char code dofly_DuanMa[10]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};// 顯示段碼值0~9
unsigned char code dofly_WeiMa[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};//分別對應相應的數碼管點亮,即位碼
unsigned char TempData[10]; //儲存顯示值的全域性變數
/*------------------------------------------------
                   函式聲明
------------------------------------------------*/
void DelayUs2x(unsigned char t);//us級延時函式聲明 
void DelayMs(unsigned char t); //ms級延時
void Display(unsigned char FirstBit,unsigned char Num);//數碼管顯示函式
unsigned char KeyScan(void);//鍵盤掃瞄
void Init_Timer0(void);//定時器初始化
/*------------------------------------------------
                    主函式
------------------------------------------------*/
void main (void)
{
	unsigned char num,i,j;                  

	Init_Timer0();

	while (1)         //主循環
	{
		num=KeyScan();
		if(num)
		{
			if(i<8) TempData[i]=dofly_DuanMa[num];
			
			i++;
			
			if(i==9)//多出一個按鍵輸入?了清屏 原本應該為8
			{
				i=0;
				for(j=0;j<8;j++)//清屏
					TempData[j]=0;
			}
		}	
	}
}
/*------------------------------------------------
 uS延時函式，含有輸入參數 unsigned char t，無返回值
 unsigned char 是定義無符號字元變數，其值的範圍是
 0~255 這裡使用晶振12M，精確延時請使用匯編,大致延時
 長度如下 T=tx2+5 uS 
------------------------------------------------*/
void DelayUs2x(unsigned char t)
{   
	while(--t);
}
/*------------------------------------------------
 mS延時函式，含有輸入參數 unsigned char t，無返回值
 unsigned char 是定義無符號字元變數，其值的範圍是
 0~255 這裡使用晶振12M，精確延時請使用匯編
------------------------------------------------*/
void DelayMs(unsigned char t)
{
     
	while(t--)
	{
		//大致延時1mS
		DelayUs2x(245);
		DelayUs2x(245);
	}
}
/*------------------------------------------------
 顯示函式，用於動態掃瞄數碼管
 輸入參數 FirstBit 表示需要顯示的第一位，如賦值2表示從第三個數碼管開始顯示
 如輸入0表示從第一個顯示。
 Num表示需要顯示的位數，如需要顯示99兩位數值則該值輸入2
------------------------------------------------*/
void Display(unsigned char FirstBit,unsigned char Num)
{
	static unsigned char i=0;


	DataPort=0;   //清空數據，防止有交替重影
	LATCH1=1;     //段鎖存
	LATCH1=0;

	DataPort=dofly_WeiMa[i+FirstBit]; //取位碼 
	LATCH2=1;     //位鎖存
	LATCH2=0;

	DataPort=TempData[i]; //取顯示數據，段碼
	LATCH1=1;     //段鎖存
	LATCH1=0;

	i++;
	if(i==Num)
	i=0;


}
/*------------------------------------------------
                    定時器初始化子程式
------------------------------------------------*/
void Init_Timer0(void)
{
	TMOD |= 0x01;	  //使用模式1，16位定時器，使用"|"符號可以在使用多個定時器時不受影響		     
	//TH0=0x00;	      //給定初值
	//TL0=0x00;
	EA=1;            //總中斷打開
	ET0=1;           //定時器中斷打開
	TR0=1;           //定時器開關打開
}
/*------------------------------------------------
                 定時器中斷子程式
------------------------------------------------*/
void Timer0_isr(void) interrupt 1 
{
	TH0=(65536-2000)/256;		  //重新賦值 2ms
	TL0=(65536-2000)%256;

	Display(0,8);       // 呼叫數碼管掃瞄

}

/*------------------------------------------------
            按鍵掃瞄函式，返回掃瞄鍵值
------------------------------------------------*/
unsigned char KeyScan(void)
{
	/********************************************************/  
	if(!KEY1)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY1)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY1);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 1;
			}
		}
	}
	/********************************************************/  
	else if(!KEY2)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY2)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY2);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 2;
			}
		}
	}
	/********************************************************/  
	else if(!KEY3)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY3)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY3);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 3;
			}
		}
	}
	/********************************************************/  
	else if(!KEY4)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY4)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY4);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 4;
			}
		}
	}
	/********************************************************/  
	else if(!KEY5)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY5)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY5);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 5;
			}
		}
	}
	/********************************************************/  
	else if(!KEY6)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY6)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY6);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 6;
			}
		}
	}
	/********************************************************/  
	else if(!KEY7)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY7)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY7);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 7;
			}
		}
	}
	/********************************************************/  
	else if(!KEY8)  //如果檢測到低電平，說明按鍵按下
	{
		DelayMs(10); //延時去抖，一般10-20ms
		if(!KEY8)     //再次確認按鍵是否按下，沒有按下則退出
		{
			while(!KEY8);//如果確認按下按鍵等待按鍵釋放，沒有則退出
			{
				return 8;
			}
		}
	}
	/********************************************************/  
	else
		return 0;
}
